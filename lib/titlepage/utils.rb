# encoding: utf-8

#
# A set of classes to hold results from the API.
# Based on the classes generated by soap4r, with attributes
# changed to use ruby conventions
#

module TitlePage

  class Response

    private

    # ensure all specified attributes are encoded as UTF-8. At this stage the
    # Titlepage API is encoded in ISO-8859-1, but this *should* continue to
    # work if they change that.
    #
    def normalise_attrib_encodings!(current_enc, attributes)
      return if current_enc.downcase == "utf-8"

      if RUBY_VERSION < "1.9"
        attributes.each do |attrib|
          if self.__send__(attrib)
            new_val = Iconv.conv("utf-8",current_enc, self.__send__(attrib))
            self.__send__("#{attrib}=", new_val)
          end
        end
      else
        current_enc = Encoding.find(current_enc)
        attributes.each do |attrib|
          if self.__send__(attrib)
            self.__send__(attrib).force_encoding(current_enc)
            self.__send__(attrib).encode!("utf-8")
          end
        end
      end
    end
  end

  class ProductIdentifier < TitlePage::Response
    attr_accessor :product_id_type
    attr_accessor :id_value

    # convert a nokogiri node to a TitlePage::ProductIdentifier object
    #
    def self.from_xml(node)
      return nil if node.nil?
      #<ProductIdentifiers xsi:type="SOAP-ENC:Array" SOAP-ENC:arrayType="tns:ProductIdentifier[1]">
      #  <item xsi:type="tns:ProductIdentifier">
      #    <ProductIDType xsi:type="xsd:string">15</ProductIDType>
      #    <IDValue xsi:type="xsd:string">9780091835132</IDValue>
      #  </item>
      #</ProductIdentifiers>
      id = self.new
      id.product_id_type = node.xpath("//item/ProductIDType/text()").to_s
      id.id_value = node.xpath("//item/IDValue/text()").to_s
      id.normalise_encodings!(node.document.encoding)
      id
    end

    # ensure all string attributes are UTF-8 encoded
    #
    def normalise_encodings!(current_enc)
      attribs = [:product_id_type, :id_value]
      normalise_attrib_encodings!(current_enc, attribs)
    end
  end

  class Title < TitlePage::Response
    attr_accessor :title_type
    attr_accessor :title_text
    attr_accessor :title_prefix
    attr_accessor :title_without_prefix
    attr_accessor :subtitle

    # convert a nokogiri node to a TitlePage::Title object
    #
    def self.from_xml(node)
      return nil if node.nil?
      #<Title xsi:type="tns:Title">
      #  <TitleType xsi:type="xsd:string">01</TitleType>
      #  <TitleText xsi:type="xsd:string">Fight Club</TitleText>
      #</Title>
      title = self.new
      title.title_type = node.xpath("//Title/TitleType/text()").first.andand.to_s
      title.title_text = node.xpath("//Title/TitleText/text()").first.andand.to_s
      title.title_prefix = node.xpath("//Title/TitlePrefix/text()").first.andand.to_s
      title.title_without_prefix = node.xpath("//Title/TitleWithoutPrefix/text()").first.andand.to_s
      title.subtitle = node.xpath("//Title/Subtitle/text()").first.andand.to_s

      # normalise encodings to utf-8
      title.normalise_encodings!(node.document.encoding)
      title
    end

    # ensure all string attributes are UTF-8 encoded
    #
    def normalise_encodings!(current_enc)
      attribs = [:title_type, :title_text, :title_prefix, :title_without_prefix, :subtitle]
      normalise_attrib_encodings!(current_enc, attribs)
    end

  end

  class Contributor < TitlePage::Response
    attr_accessor :sequence_number
    attr_accessor :contributor_role
    attr_accessor :person_name
    attr_accessor :person_name_inverted
    attr_accessor :titles_before_names
    attr_accessor :key_names

    # convert a nokogiri node to a TitlePage::Contributor object
    #
    def self.from_xml(node)
      return nil if node.nil?
      #<Contributors xsi:type="SOAP-ENC:Array" SOAP-ENC:arrayType="tns:Contributor[1]">
      #  <item xsi:type="tns:Contributor">
      #    <SequenceNumber xsi:type="xsd:integer">1</SequenceNumber>
      #    <ContributorRole xsi:type="xsd:string">A01</ContributorRole>
      #    <PersonNameInverted xsi:type="xsd:string">Palahniuk, Chuck</PersonNameInverted>
      #  </item>
      #</Contributors>
      contrib = self.new
      contrib.sequence_number = node.xpath("//item/SequenceNumber/text()").first.andand.to_s.andand.to_i
      contrib.contributor_role = node.xpath("//item/ContributorRole/text()").first.andand.to_s
      contrib.person_name = node.xpath("//item/PersonName/text()").first.andand.to_s
      contrib.person_name_inverted = node.xpath("//item/PersonNameInverted/text()").first.andand.to_s
      contrib.titles_before_names = node.xpath("//item/TitlesBeforeNames/text()").first.andand.to_s
      contrib.key_names = node.xpath("//item/KeyNames/text()").first.andand.to_s
      contrib.normalise_encodings!(node.document.encoding)
      contrib
    end

    # ensure all string attributes are UTF-8 encoded
    #
    def normalise_encodings!(current_enc)
      attribs = [:contributor_role, :person_name, :person_name_inverted, :titles_before_names, :key_names]
      normalise_attrib_encodings!(current_enc, attribs)
    end

  end

  class Stock < TitlePage::Response
    attr_accessor :on_hand
    attr_accessor :on_order

    # convert a nokogiri node to a TitlePage::Stock object
    #
    def self.from_xml(node)
      return nil if node.nil?
      #<Stock xsi:type="tns:Stock">
      #  <OnHand xsi:type="xsd:string">Out Of Stock</OnHand>
      #  <OnOrder xsi:type="xsd:string">Yes</OnOrder>
      #</Stock>
      stock = self.new
      stock.on_hand = node.xpath("//Stock/OnHand/text()").first.andand.to_s
      stock.on_order = node.xpath("//Stock/OnOrder/text()").first.andand.to_s
      stock.normalise_encodings!(node.document.encoding)
      stock
    end

    # ensure all string attributes are UTF-8 encoded
    #
    def normalise_encodings!(current_enc)
      attribs = [:on_hand, :on_order]
      normalise_attrib_encodings!(current_enc, attribs)
    end
  end

  class Price < TitlePage::Response
    attr_accessor :price_type_code
    attr_accessor :price_amount

    # convert a nokogiri node to a TitlePage::Price object
    #
    def self.from_xml(node)
      return nil if node.nil?
      #<Price xsi:type="tns:Price">
      #  <PriceAmount xsi:type="xsd:decimal">24.95</PriceAmount>
      #</Price>
      price = self.new
      price.price_type_code = node.xpath("//Price/PriceTypeCode/text()").first.andand.to_s
      val = node.xpath("//Price/PriceAmount/text()").first.andand.to_s
      price.price_amount = BigDecimal.new(val) if val.size > 0
      price.normalise_encodings!(node.document.encoding)
      price
    end

    # ensure all string attributes are UTF-8 encoded
    #
    def normalise_encodings!(current_enc)
      attribs = [:price_type_code]
      normalise_attrib_encodings!(current_enc, attribs)
    end
  end

  class SupplyDetail < TitlePage::Response
    attr_accessor :supplier_name
    attr_accessor :supplier_role
    attr_accessor :product_availability
    attr_accessor :expected_ship_date
    attr_accessor :stock
    attr_accessor :pack_quantity
    attr_accessor :price

    # convert a nokogiri node to a TitlePage::SupplyDetail object
    #
    def self.from_xml(node)
      return nil if node.nil?
      #<SupplyDetail xsi:type="tns:SupplyDetail">
      #  <SupplierName xsi:type="xsd:string">Random House Australia</SupplierName>
      #  <ProductAvailability xsi:type="xsd:string">20</ProductAvailability>
      #  <Stock xsi:type="tns:Stock">
      #    <OnHand xsi:type="xsd:string">Out Of Stock</OnHand>
      #    <OnOrder xsi:type="xsd:string">Yes</OnOrder>
      #  </Stock>
      #  <PackQuantity xsi:type="xsd:integer">28</PackQuantity>
      #  <Price xsi:type="tns:Price">
      #    <PriceAmount xsi:type="xsd:decimal">24.95</PriceAmount>
      #  </Price>
      #</SupplyDetail>

      sd = self.new
      sd.supplier_name = node.xpath("//SupplyDetail/SupplierName/text()").first.andand.to_s
      sd.supplier_role = node.xpath("//SupplyDetail/SupplierRole/text()").first.andand.to_s
      sd.product_availability = node.xpath("//SupplyDetail/ProductAvailability/text()").first.andand.to_s
      sd.expected_ship_date = node.xpath("//SupplyDetail/ExpectedShipDate/text()").first.andand.to_s
      sd.stock = TitlePage::Stock.from_xml(node.xpath("//SupplyDetail/Stock").first)
      sd.pack_quantity = node.xpath("//SupplyDetail/PackQuantity/text()").first.andand.to_s.andand.to_i
      sd.price = TitlePage::Price.from_xml(node.xpath("//SupplyDetail/Price").first)
      sd.normalise_encodings!(node.document.encoding)
      sd
    end

    # ensure all string attributes are UTF-8 encoded
    #
    def normalise_encodings!(current_enc)
      attribs = [:supplier_name, :supplier_role, :product_availability, :expected_ship_date]
      normalise_attrib_encodings!(current_enc, attribs)
    end
  end

  class Product
    attr_accessor :product_identifiers
    attr_accessor :title
    attr_accessor :contributors
    attr_accessor :supply_detail

    def self.from_xml(node)
      return nil if node.nil?

      product = self.new

      product.product_identifiers = node.xpath("//Product/ProductIdentifiers/item").map do |node|
        TitlePage::ProductIdentifier.from_xml(node)
      end

      title_node = node.xpath("//Product/Title")
      product.title = TitlePage::Title.from_xml(title_node)

      product.contributors = node.xpath("//Product/Contributors/item").map do |node|
        TitlePage::Contributor.from_xml(node)
      end

      sd_node = node.xpath("//Product/SupplyDetail")
      product.supply_detail = TitlePage::SupplyDetail.from_xml(sd_node)

      product
    end

    # return a simple hash representation of this product
    #
    def to_hash
      {
        :supplier => self.supply_detail.supplier_name,
        :title    => self.title.title_text,
        :ean      => self.product_identifiers.first.id_value,
        :price    => self.supply_detail.price.price_amount,
        :availability => self.supply_detail.product_availability,
        :contributors => self.contributors.collect { |c| c.person_name_inverted }
      }
    end

    # return a simple YAML representation of this product
    #
    def to_yaml
      YAML.dump(to_hash)
    end
  end
end
